import React, {
  createContext,
  useState,
  useCallback,
  useContext,
  useEffect,
  useRef
} from "react";
import EthereumProvider from "@walletconnect/ethereum-provider";
import { BrowserProvider } from "ethers";

const WalletContext = createContext(null);

export const WalletProvider = ({ children }) => {
  const [account, setAccount] = useState(null);
  const [chainId, setChainId] = useState(null);
  const [provider, setProvider] = useState(null);
  const [walletType, setWalletType] = useState(null);
  const [error, setError] = useState(null);
  const [isConnecting, setIsConnecting] = useState(false);
  const isMounted = useRef(true);

  const isMobile = () =>
    /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );

  /* ----------------------------- CONNECT ----------------------------- */
  const connectWallet = useCallback(async (type) => {
    setIsConnecting(true);
    setError(null);

    try {
      let ethersProvider;

      /* -------- MetaMask -------- */
      if (type === "metamask") {
        if (!window.ethereum) {
          if (isMobile()) {
            const link = `https://metamask.app.link/dapp/${window.location.host}`;
            window.location.href = link;
            return;
          }
          throw new Error("MetaMask is not installed.");
        }

        const injected =
          window.ethereum.providers?.find((p) => p.isMetaMask) ||
          window.ethereum;

        ethersProvider = new BrowserProvider(injected);

        const accounts = await ethersProvider.send("eth_requestAccounts", []);
        const network = await ethersProvider.getNetwork();

        setAccount(accounts[0]);
        setChainId(Number(network.chainId));
        setProvider(ethersProvider);
        setWalletType("metamask");
      }

      /* -------- WalletConnect -------- */
      if (type === "walletconnect") {
        const projectId = process.env.REACT_APP_WC_PROJECT_ID;

        if (!projectId) {
          throw new Error("Missing REACT_APP_WC_PROJECT_ID");
        }

        const wcProvider = await EthereumProvider.init({
          projectId,
          chains: [1, 137, 8453], // ETH, Polygon, Base
          showQrModal: true
        });

        await wcProvider.connect();

        ethersProvider = new BrowserProvider(wcProvider);

        const signer = await ethersProvider.getSigner();
        const address = await signer.getAddress();
        const network = await ethersProvider.getNetwork();

        setAccount(address);
        setChainId(Number(network.chainId));
        setProvider(ethersProvider);
        setWalletType("walletconnect");
      }

      localStorage.setItem("walletType", type);
    } catch (err) {
      console.error(err);
      setError(err.message || "Wallet connection failed");
    } finally {
      if (isMounted.current) {
        setIsConnecting(false);
      }
    }
  }, []);

  /* ---------------------------- DISCONNECT ---------------------------- */
  const disconnectWallet = useCallback(async () => {
    try {
      if (walletType === "walletconnect" && provider?.provider?.disconnect) {
        await provider.provider.disconnect();
      }
    } catch (_) {}

    setAccount(null);
    setChainId(null);
    setProvider(null);
    setWalletType(null);
    setError(null);
    localStorage.removeItem("walletType");
  }, [provider, walletType]);

  /* ----------------------- AUTO-RECONNECT ----------------------- */
  useEffect(() => {
    const saved = localStorage.getItem("walletType");
    if (saved && !account && !isConnecting) {
      connectWallet(saved);
    }
  }, [account, connectWallet, isConnecting]);

  /* ---------------------- CLEANUP ON UNMOUNT --------------------- */
  useEffect(() => {
    return () => {
      isMounted.current = false;
    };
  }, []);

  /* ----------------------------- CONTEXT ----------------------------- */
  return (
    <WalletContext.Provider
      value={{
        account,
        chainId,
        provider,
        walletType,
        error,
        isConnecting,
        connectWallet,
        disconnectWallet,
        getSigner: async () => {
          if (!provider) throw new Error("Wallet not connected");
          return provider.getSigner();
        }
      }}
    >
      {children}
    </WalletContext.Provider>
  );
};

export const useWallet = () => useContext(WalletContext);